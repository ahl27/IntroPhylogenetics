[{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/BuildingTrees.html","id":"distance-matrices","dir":"Articles","previous_headings":"","what":"Distance Matrices","title":"Building Trees","text":"phylogenetic reconstruction algorithms rely upon constructing distance matrices. variety way , purposes illustration ’ll just using Hamming Distance, one simplest methods. complex methods can use nucleotide amino acid substitution models. Let’s construct toy dataset purposes illustration:  pair sequences, count proportion residues match mark distance . example calculating distance, consider first two sequences set: \\[\\begin{align*} &1)\\;\\;&AGACT&\\\\ &2)\\;\\;&AGACG& \\end{align*}\\] Since sequences differ 1 5 total residues, distance \\(\\frac{1}{5}=0.2\\). can quickly calculate complete distance matrix sequences following: Notice distance 1 2 0.2, just calculated . Now can begin create trees.","code":"sequenceSet <- DNAStringSet(c('AGACT',                               'AGACG',                               'TCATT',                               'TGCTG',                               'AGCTG')) names(sequenceSet) <- 1:5 dm <- DistanceMatrix(sequenceSet, type='dist', verbose=F) dm ##     1   2   3   4   5 ## 1 0.0 0.2 0.6 0.8 0.6 ## 2 0.2 0.0 0.8 0.6 0.4 ## 3 0.6 0.8 0.0 0.6 0.8 ## 4 0.8 0.6 0.6 0.0 0.2 ## 5 0.6 0.4 0.8 0.2 0.0"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/BuildingTrees.html","id":"upgmawpgma","dir":"Articles","previous_headings":"","what":"UPGMA/WPGMA","title":"Building Trees","text":"simplest tree building method Unweighted Pair Group Method Arithmetic Means (UPGMA). hierarchical clustering algorithm sequentially builds tree bottom . algorithm begins distance matrix, proceeds following steps: Identify pair nodes lowest distance \\(d_{min}\\). ’ve multiplied distances 10 make easier read (doesn’t make difference final result). Create new node \\(N_{new}\\) joins pairs nodes, create branch lengths leaf equidistant \\(N_{new}\\) total branch length \\(N_{new}\\) leaf half \\(d_{min}\\). case, \\(d_{min} = 2\\) new node called \\(u\\). Combine two rows distance matrix one row replacing pair entries average. average weighted number leaves pair combined, two rows clusters multiple leaves, average weighted accordingly.  Repeat steps nodes combined distance matrix single row column.    Note UPGMA methods always create ultrametric tree, means tree rooted leaves equidistant root. implies molecular clock (rate mutation across lineages tree). can create UPGMA tree R commands. Note R doubles lengths obtained , ’m going multiply distance matrix 5 get scale factor example worked .  variation UPGMA WPGMA, W stands ‘weighted’. difference UPGMA WPGMA bit counter-intuitive. Recall combine two rows distance matrix UPGMA, weight average number leaves node combined. WPGMA, weight number leaves node, instead treat node equal weight. example, consider following distance matrix: \\[ \\begin{matrix}     & n_1 & n_2 & n_3 \\\\ n_1 & 0   & 3   & 5  \\\\ n_2 & -   & 0   & 3  \\\\ n_3 & -   & -   & 0  \\\\ \\end{matrix}\\] Now suppose node \\(n_1\\) 10 leaves, node \\(n_2\\) 2 leaves, node \\(n_3\\) 1 leaf. wanted combine nodes \\(n_1\\) \\(n_2\\) node \\(u\\) using UPGMA, distance \\(u\\) \\(n_3\\) calculated following formula: \\[\\begin{align*} d_{UPGMA}(u, n_3) &= \\frac{1}{|n_1| + |n_2|} \\left(|n_1|*d(n_1,n_3) + |n_2|*d(n_2,n_3) \\right)\\\\ \\\\ &= \\frac{1}{10+2} \\left(10*5 + 2*3 \\right) \\\\ \\\\ &= 4.67 \\end{align*}\\] However, combined WPGMA, instead ignore number leaves cluster just take simple arithmetic average, follows: \\[\\begin{align*} d_{WPGMA}(u, n_3) &= \\frac{1}{2} \\left(d(n_1,n_3) + d(n_2,n_3) \\right)\\\\ \\\\ &= \\frac{1}{2} \\left(5 + 3 \\right) \\\\ \\\\ &= 4 \\end{align*}\\] ’re probably wondering, “weighted PGMA use unweighted combinations vice-versa?” answer lies ’re referring talk pair combinations (un)weighted. Since UPGMA weights node number leaves, ’s correcting nodes representing clades difference sizes. words, combination inherently weighted, UPGMA uses clever way “undo” combination. WPGMA, contrast, weight clade size, thus combinations biased (weighted) number leaves nodes. Implementing WPGMA trees similar UPGMA trees (gives result example):  also methods combining distance matrices–see help page hclust examples.","code":"# UPGMA Tree dend <- as.dendrogram(hclust(dm*5, method='average')) plot(dend) # WPGMA Tree dend <- as.dendrogram(hclust(dm*5, method='mcquitty')) plot(dend)"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/BuildingTrees.html","id":"neighbor-joining-trees","dir":"Articles","previous_headings":"","what":"Neighbor Joining Trees","title":"Building Trees","text":"Another common approach building trees Neighbor-Joining (NJ) method. method also utilizes distance matrices, proceeds top-rather UPGMA’s bottom-approach. ’ll use distance matrix (multiplied 10 simpler visualization). algorithm proceeds following steps: Start star tree (connected single root node), record row column sums row/column matrix.  Create Q-matrix, matrix dimensions distance matrix, element given following formula: \\[Q[,j] = (n-2)d(,j) - R() - C(j)\\]       \\(n\\) number nodes consideration (number       rows distance matrix), \\(d(,j)\\) distance node \\(\\)       node \\(j\\), \\(R()\\) sum \\(\\)’th row, \\(C(j)\\) sum       \\(j\\)’th column. Identify smallest pair \\(f,g\\) Q-matrix, combine corresponding nodes adding intermediate node \\(N_{int}\\) tree.  Calculate edge lengths \\(N_{int}\\) \\(f,g\\) following formula: \\[\\begin{align*} d(N_{int}, f) &= \\frac{1}{2}(d[,j]) + \\frac{1}{2(n-2)}(R() - C(j))\\\\ \\\\ d(N_{int}, g) &= d[,j] - d[N_{int}, f] \\end{align*}\\]       case, \\(d[1,2] = 2\\), \\(R(1) = 22\\), \\(C(2) = 20\\). Thus, new node \\(u\\), : Calculate distance \\(N_{int}\\) nodes \\(h\\) following formula: \\[d(h, N_{int}) = \\frac{1}{2}(d[h,g] + d[h,f] - d[f,g])\\] Repeat full tree constructed.   three nodes left, just need figure branch lengths.  can exact way .  Neighbor-Joining trees can created R following commands. Note output slightly different due different method calculating initial distance matrix.","code":"dend <- TreeLine(myDistMatrix=dm, method='NJ') plot_tree_unrooted(dend, 'NJ')"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/BuildingTrees.html","id":"maximum-parsimony-trees","dir":"Articles","previous_headings":"","what":"Maximum Parsimony Trees","title":"Building Trees","text":"last way construct phylogenies discuss maximum parsimony. method relies assumption simplest method likely best, thus tries find tree minimizes number changes tree. tree called “parsimonious” tree. illustrate looks like, ’ll look subset initial set sequences. ’ve also included distance matrix corresponding number state transitions required switch one sequence another (Hamming distance).  Notice sequences 1 2 similar, sequences 4 5 similar. optimal reconstruction place sequences 1 2 close together sequences 4 5 close together, since pairs require fewer transitions convert . set 4 nodes, four possible topologies:  Three trees single internal branch, one star tree branches. top left tree parsimonious, minimizes transition cost along particular path tree. Parsimony tree reconstructions don’t use distance matrices, instead randomly walk tree space find tree parsimonious. purely random strategy take eons complete, modern methods use various optimizations. Common techniques include iteratively adding branches maximize parsimony branch added, /perturb trees performing nearest neighbor interchanges (NNIs). NNIs take quartet tree swap partition check rearrangement parsimonious. example NNI taking quartets previous graphic checking types parsimonious. can maximum parsimony reconstructions R using following code:","code":"dend <- TreeLine(sequenceSet, method='MP') plot_tree_unrooted(dend, 'MP')"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"ComparingTrees","text":"’ll start slightly larger test dataset can clearly see differences tree constructions. following codeblocks read set 25 simulated alignments, constructs phylogenetic trees using three methods discussed previously. Visualizing trees ’ve made:","code":"# External data file, contains simulated alignment simSeqsFile <- system.file('extdata', 'Simulated_v1.fas', package='IntroPhylogenetics', mustWork=TRUE)  simAli <- suppressWarnings(readDNAStringSet(simSeqsFile))[1:25] names(simAli) <- 1:25 simDm <- DistanceMatrix(simAli, type='dist', penalizeGapGapMatches=FALSE, verbose=FALSE)  UPGMAtree <- as.dendrogram(hclust(simDm, method='average')) NJtree <- TreeLine(simAli, myDistMatrix=simDm, method='NJ') MPtree <- TreeLine(simAli, myDistMatrix=simDm, method='MP') plot_tree_unrooted(UPGMAtree, 'UPGMA') plot_tree_unrooted(NJtree, 'NJ') plot_tree_unrooted(MPtree, 'MP')"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"partitions","dir":"Articles","previous_headings":"","what":"Partitions","title":"ComparingTrees","text":"dive tree distances, ’s important understand concept partitions. bifurcating unrooted tree, every edge divides set leaf nodes two sets. form basis many tree comparison algorithms. Let’s look toy example:  Note numbered edge tree splits labeled leaf nodes two distinct groups either side . Leaf edges trivially split tree partition just leaf everything else, internal edges split leaves interesting partitions.","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"rf-distance","dir":"Articles","previous_headings":"","what":"RF Distance","title":"ComparingTrees","text":"Robinson-Foulds (RF) distance measures similarity partitions tree. Let’s look toy example two small trees internal partitions labeled (internal edges circled green):  Now let \\(\\) number partitions unique first tree, \\(B\\) number partitions unique second tree. RF distance (also called symmetric difference metric) simply quantity \\((+B)\\). example, note edge 2 identical partition edge II. Thus, first tree one unique partition, second tree one unique partition, RF distance \\(1+1=2\\). implementations change metric slightly scaling , either dividing two scaling metric maximum value 1. latter operation can done dividing maximum possible score, just sum total number branches. case, total number internal branches 4 (2 tree), RF distance \\(0.5\\).","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"r-implementation","dir":"Articles","previous_headings":"RF Distance","what":"R implementation","title":"ComparingTrees","text":"","code":"RF_dist_external <- function(dend1, dend2){   tf <- tempfile()   WriteDendrogram(dend1, file=tf, quoteLabels=FALSE)   predTree1 <- read.tree(tf)      tf <- tempfile()   WriteDendrogram(dend2, file=tf, quoteLabels=FALSE)   predTree2 <- read.tree(tf)      return(dist.topo(predTree1, predTree2, 'PH85')) }  RF_dist_external(UPGMAtree, NJtree) ##       tree1 ## tree2    12 RF_dist_external(UPGMAtree, MPtree) ##       tree1 ## tree2    20 RF_dist_external(NJtree, MPtree) ##       tree1 ## tree2    14"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"drawbacks","dir":"Articles","previous_headings":"RF Distance","what":"Drawbacks","title":"ComparingTrees","text":"RF distance widely used, common issues kept mind using : Similar trees can receive value Range values depends tree shape Doesn’t look branch length Can’t recognize similar clades (difference increases distance score) Original implementation assumes bifurcating, unrooted tree leaf set Distance immediately statistically interpretable (larger \\(\\neq\\) significant) drawbacks accounted subsequent optimization, ‘generalized RF distances’ created can account similar sets working multifurcating trees different leaf sets.","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"kf-distance","dir":"Articles","previous_headings":"","what":"KF Distance","title":"ComparingTrees","text":"Kuhner-Felsenstein (KF) distance attempts incorporate branch lengths RF distance gain richer description differences two trees. Recall RF distance number unique (non-shared) partitions tree. KF distance instead taken sum squared difference branch lengths equivalent partition two trees. partition unique particular tree, taken branch length 0 tree. updated version previous example branch lengths added pink (partitions labeled):  also examine leaf branches, since leaf set branch lengths identical, branches cancel . One pair branches equivalent partition (2 II), two unique. KF distance : \\[\\begin{align*} KF(Tr1, Tr2) &= (len(1) - 0)^2 + (0 - len())^2 + (len(2) - len(II))^2 \\\\ &= (2-0)^2 + (0-6)^2 + (2-3)^2 \\\\ &= 41 \\end{align*}\\] advantages RF distance can incorporate branch lengths addition topology, allows downweight small differences topology upweight large differences.","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"r-implementation-1","dir":"Articles","previous_headings":"KF Distance","what":"R Implementation","title":"ComparingTrees","text":"","code":"KF_dist_external <- function(dend1, dend2){   tf <- tempfile()   WriteDendrogram(dend1, file=tf, quoteLabels=FALSE)   predTree1 <- read.tree(tf)      tf <- tempfile()   WriteDendrogram(dend2, file=tf, quoteLabels=FALSE)   predTree2 <- read.tree(tf)      return(dist.topo(predTree1, predTree2, method='score')) }  RF_dist_external(UPGMAtree, NJtree) ##       tree1 ## tree2    12 RF_dist_external(UPGMAtree, MPtree) ##       tree1 ## tree2    20 RF_dist_external(NJtree, MPtree) ##       tree1 ## tree2    14"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"other-metrics","dir":"Articles","previous_headings":"","what":"Other Metrics","title":"ComparingTrees","text":"two commonly used metrics, many implemented TreeDist package. Notable recent tree distance measures include: TreeDist::TreeDistance methods, using generalized RF distance Smith (2020) TreeDist::JaccardRobinsonFoulds TreeDist:NyeSimilarity, generalized RF distances. TreeDist::KendallColijn, distance measures difference path lengths pairs leaves TreeDist::MASTSize, distance measures largest agreement subtree two trees","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"manual-implementations","dir":"Articles","previous_headings":"","what":"Manual Implementations","title":"ComparingTrees","text":"wrote implementations distances scratch illustrate functions working hood. Note external packages incorporate optimizations didn’t implement lead different results.","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"helper-functions","dir":"Articles","previous_headings":"Manual Implementations","what":"Helper functions","title":"ComparingTrees","text":"code block contains several helper functions used later.","code":"flatdendrapply <- function(dend, NODEFUN, LEAFFUN=NODEFUN, INCLUDEROOT=TRUE, ...){   ## Applies a function to each node (internal and leaf) of the tree   ## Returns a flat list   val <- lapply(dend,                  \\(x){                   if (is.null(attr(x, 'leaf'))){                     v <- list(NODEFUN(x, ...))                     for ( child in x ) v <- c(v, Recall(child))                     return(v)                   }                    else if (!is(LEAFFUN, 'function'))                     return(list())                   else                      return(list(LEAFFUN(x, ...)))                 }   )   retval <- unlist(val, recursive=FALSE)   if (!INCLUDEROOT)     retval[[1]] <- NULL    return(retval) }  isLeaf <- function(dendNode){   return(!is.null(attr(dendNode, 'leaf')) && attr(dendNode, 'leaf')) }  equivPart <- function(set1, set2, fullset){   # Checks if two partitions are equivalent   inverseset1 <- fullset[!(fullset %in% set1)]   return(setequal(set1,set2) || setequal(inverseset1, set2)) }  get_branch_length <- function(dendNode){   ## Helper function for KF distance, gets partition and branch length   ## of all branches Because of weirdness each node will return two values,   ## the result just needs some slight post-processing    ## (see KF_Distance function for example)   if(isLeaf(dendNode)){     return(0)   }      h <- attr(dendNode, 'height')   n1 <- dendNode[[1]]   n2 <- dendNode[[2]]   c1 <- attr(n1, 'height')   c2 <- attr(n2, 'height')      if(isLeaf(n1))     labs1 <- attr(n1, 'label')   else      labs1 <- unlist(n1)      if (isLeaf(n2))     labs2 <- attr(n2, 'label')   else     labs2 <- unlist(n2)    l1 <- list(length=h-c1, part=labs1)   l2 <- list(length=h-c2, part=labs2)   return(list(l1, l2)) }"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"robinson-foulds-distance","dir":"Articles","previous_headings":"Manual Implementations","what":"Robinson-Foulds Distance","title":"ComparingTrees","text":"","code":"RF_Distance <- function(dend1, dend2){   # Get all partitions   part1 <- flatdendrapply(dend1, unlist, NULL)   part2 <- flatdendrapply(dend2, unlist, NULL)   allmembers <- unique(c(unlist(dend1), unlist(dend2)))      # Calculate tree distance   A <- B <- 0   for ( i in seq_along(part1))     A <- A + !any(sapply(part2, \\(x) equivPart(part1[[i]], x, allmembers)))      for ( i in seq_along(part2))     B <- B + !any(sapply(part1, \\(x) equivPart(part2[[i]], x, allmembers)))      # This implementation normalizes to get a distance out of 1   return((A+B) / (length(part1) + length(part2))) }"},{"path":"https://www.ahl27.com/IntroPhylogenetics/articles/ComparingTrees.html","id":"kuhner-felsenstein-distance","dir":"Articles","previous_headings":"Manual Implementations","what":"Kuhner-Felsenstein Distance","title":"ComparingTrees","text":"","code":"KF_Distance <- function(dend1, dend2){   # Get all branch lengths and partitions   part1 <- flatdendrapply(dend1, get_branch_length, NULL)   part2 <- flatdendrapply(dend2, get_branch_length, NULL)      # Each function call returns a length of list two, we just want the members   part1 <- unlist(part1, recursive=FALSE)   part2 <- unlist(part2, recursive=FALSE)      # Root is split into two branches, need to combine   part1[[1]]$length <- part1[[1]]$length + part1[[2]]$length   part2[[1]]$length <- part2[[1]]$length + part2[[2]]$length   part1[[2]] <- part2[[2]] <- NULL      allmembers <- unique(c(unlist(dend1), unlist(dend2)))      # For each   treedist <- 0   for ( i in seq_along(part1)){     check <- sapply(part2, \\(x) equivPart(part1[[i]]$part, x$part, allmembers))     if (any(check)){       loc <- which(check)       treedist <- treedist + (part1[[i]]$length - part2[[loc]]$length)**2     }   }   for ( i in seq_along(part2)){     check <- sapply(part1, \\(x) equivPart(part2[[i]]$part, x$part, allmembers))     if (any(check)){       loc <- which(check)       treedist <- treedist + (part2[[i]]$length - part1[[loc]]$length)**2     }   }      ## divided by two since duplicates will be added twice   ## probably worth reworking at some point to avoid adding duplicates twice,   ## this is just a quick fix   return(sqrt(treedist/2)) } RFDists <- KFDists <- matrix(0, nrow=3, ncol=3) rownames(RFDists) <- rownames(KFDists) <- colnames(RFDists) <- colnames(KFDists) <- c('UPGMA', 'NJ', 'MP')  RFDists[1,2] <- RFDists[2,1] <- RF_Distance(UPGMAtree, NJtree) RFDists[1,3] <- RFDists[3,1] <- RF_Distance(UPGMAtree, MPtree) RFDists[2,3] <- RFDists[3,2] <- RF_Distance(NJtree, MPtree) KFDists[1,2] <- KFDists[2,1] <- KF_Distance(UPGMAtree, NJtree) KFDists[1,3] <- KFDists[3,1] <- KF_Distance(UPGMAtree, MPtree) KFDists[2,3] <- KFDists[3,2] <- KF_Distance(NJtree, MPtree)  RFDists ##           UPGMA        NJ        MP ## UPGMA 0.0000000 0.2608696 0.4347826 ## NJ    0.2608696 0.0000000 0.3043478 ## MP    0.4347826 0.3043478 0.0000000 KFDists ##           UPGMA        NJ        MP ## UPGMA 0.0000000 0.9712953 0.9622558 ## NJ    0.9712953 0.0000000 0.3260003 ## MP    0.9622558 0.3260003 0.0000000"},{"path":"https://www.ahl27.com/IntroPhylogenetics/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aidan Lakshman. Author, maintainer.","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lakshman (2022). IntroPhylogenetics: Introduction Phylogeitics. R package version 1.0.0, https://www.ahl27.com/IntroPhylogenetics/.","code":"@Manual{,   title = {IntroPhylogenetics: Introduction to Phylogeitics},   author = {Aidan Lakshman},   year = {2022},   note = {R package version 1.0.0},   url = {https://www.ahl27.com/IntroPhylogenetics/}, }"},{"path":"https://www.ahl27.com/IntroPhylogenetics/index.html","id":"welcome","dir":"","previous_headings":"","what":"Introduction to Phylogenetic Methods","title":"Introduction to Phylogenetic Methods","text":"repository serves place put miscellaneous tutorials ’ve written conferences, lab meetings, settings. far, ’ve included basic introduction common methods used phylogenetics. ’ll keep page updated new tutorials make ! jump tutorials, check “Lessons” tab top bar. want return website, can either click click “Back Website” top bar. Please let know issues things aren’t clear tutorials! main goal tutorial useful readers, ’m always interested feedback. Feel free send email ahl27@pitt.edu, open issue GitHub Repository. Thank !","code":""},{"path":"https://www.ahl27.com/IntroPhylogenetics/index.html","id":"useful-links","dir":"","previous_headings":"","what":"Useful Links","title":"Introduction to Phylogenetic Methods","text":"DECIPHER SynExtend Related Tutorials Lab!          work licensed Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":[]},{"path":"https://www.ahl27.com/IntroPhylogenetics/news/index.html","id":"general-notes-1-0","dir":"Changelog","previous_headings":"","what":"General Notes","title":"Version 1.0","text":"Initialization package Implementation Building Trees tutorial Implementation Comparing Trees tutorial","code":""}]
